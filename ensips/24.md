---
description: 'Standardized metadata format for Ethereum smart contracts registered through ENS with canonical ID grammar, hierarchical schema system, and validation framework'
contributors: ['accessor.eth']
ensip:
  created: '2025-10-15'
  status: 'draft'
---

# ENSIP-X: ENS Contract Metadata Standards and Naming Convention

## Table of Contents

1. [Abstract](#abstract)
2. [Status and Scope](#status-and-scope)
3. [Terminology and Conformance Language](#terminology-and-conformance-language)
4. [Specification](#specification)
   - 4.1 [Core Metadata Schema](#core-metadata-schema)
   - 4.2 [Canonical ID Grammar](#canonical-id-grammar)
   - 4.3 [Hierarchical Schema System](#hierarchical-schema-system)
   - 4.4 [Proxy Contract Support](#proxy-contract-support)
   - 4.5 [Security Attestation](#security-attestation)
   - 4.6 [Validation Framework](#validation-framework)
5. [Conformance](#conformance)
6. [Backwards Compatibility and Migration](#backwards-compatibility-and-migration)
7. [Implementation Guidance](#implementation-guidance)
8. [Security Considerations](#security-considerations)
9. [Governance](#governance)
10. [References](#references)
11. [Appendices](#appendices)
    - [Appendix A: Examples](#appendix-a-examples)
    - [Appendix B: JSON Schemas](#appendix-b-json-schemas)
    - [Appendix C: Solidity Type Definitions](#appendix-c-solidity-type-definitions)
    - [Appendix D: Domain-Based Dependency Examples](#appendix-d-domain-based-dependency-examples)
    - [Appendix E: Change Log](#appendix-e-change-log)

## Abstract

This ENSIP establishes a standardized metadata format for Ethereum smart contracts registered through the Ethereum Name Service (ENS). The standard defines a canonical ID grammar, hierarchical schema system, comprehensive dependency mapping, data-size based fee system, and validation framework to ensure consistency, discoverability, and interoperability across the Ethereum ecosystem.

## Status and Scope

**Status:** Draft (created 2024-10-15)

**Scope:** This standard applies to all Ethereum smart contracts registered through ENS that require standardized metadata for discoverability, interoperability, and security verification.

**Non-goals:** This standard does not define implementation details for specific metadata registries, fee mechanisms, or governance processes beyond the minimum requirements for compliance.

## Motivation

The Ethereum ecosystem lacks standardized metadata formats for smart contracts, leading to several key issues. **Fragmentation** occurs as metadata and naming conventions are not unified, resulting in disparate systems and formats across projects. **Limited Discoverability** stems from the absence of standard categories and schema, making it challenging to locate, identify, or organize contracts effectively. **Unreliable Data Quality** manifests as metadata that is often incomplete, outdated, or inconsistently formatted, impeding analytics and automation. **Interoperability Barriers** arise without a common metadata grammar, hindering integration across different protocols and ecosystems. **Security Information Gaps** exist as security-related details and audit results are inconsistently reported, making risk assessment difficult. **Dependency Management** lacks standardization for tracking contract dependencies, libraries, and interfaces across the ecosystem. **Economic Sustainability** is challenged by the absence of a fair, scalable mechanism for funding metadata infrastructure and ecosystem development.

This standard addresses these issues by providing a unified metadata framework that promotes consistency, enables automated validation, and supports hierarchical organization of contract information.

## Terminology and Conformance Language

### Conformance Keywords

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Key Terms

- **metadataHash**: SHA-256 hash of the complete metadata artifact for unique identification and ENS text record reference
- **ensRoot**: ENS subdomain root domain (e.g., uniswap.defi.{root}.eth)
- **proxyType**: Type of proxy contract pattern (transparent, uups, beacon, diamond, minimal, immutable)
- **attestation**: Cryptographic verification of metadata authenticity and integrity
- **canonical ID**: Structured identifier following the grammar: org.protocol.category.role[.variant].v{version}.{chainId}
- **CCIP Read**: Cross-Chain Interoperability Protocol for offchain data retrieval (EIP-3668)
- **JSON Schema**: Draft 07 specification for metadata structure validation

## Specification

### Core Metadata Schema

All ENS contract metadata MUST conform to the JSON Schema defined in [Appendix B](#appendix-b-json-schemas). The schema defines the following required fields:

- **id**: Canonical identifier following ENSIP-X grammar
- **org**: Organization identifier (lowercase, hyphen-separated)
- **protocol**: Protocol identifier (lowercase, hyphen-separated)
- **category**: Primary category classification
- **role**: Contract role/function (lowercase, descriptive)
- **version**: Semantic version format
- **chainId**: Target blockchain network ID
- **addresses**: Array of contract addresses across chains
- **metadataHash**: SHA-256 hash of the complete metadata artifact

The schema also defines optional fields for standards compliance, artifacts, lifecycle information, security attestation, proxy contract details, and subdomain configuration.

### Solidity Type Definitions

Compliant implementations MUST use the Solidity structs and enums defined in [Appendix C](#appendix-c-solidity-type-definitions) for on-chain representation of ENS contract metadata. These types provide structured data storage for contract integration and include definitions for metadata structures, dependency information, security attestation, and contract categories.

### Canonical ID Grammar

The `id` field MUST follow this grammar:

```
org.protocol.category.role[.variant].v{version}.{chainId}
```

| Component | Description | Example |
|-----------|-------------|---------|
| `org` | Organization identifier (lowercase, hyphen-separated) | `uniswap` |
| `protocol` | Protocol name (lowercase, hyphen-separated) | `uniswap` |
| `category` | Root category (MUST match registered categories) | `defi` |
| `role` | Contract role/function (lowercase, descriptive) | `router` |
| `variant` | Optional protocol variant identifier | `v3` |
| `version` | Semantic version format | `v3-1-0` |
| `chainId` | Target blockchain network ID | `1` |

**Examples:** `uniswap.uniswap.defi.router.v3-1-0.1`, `ens.ens.dao.governor.v1-0-0.1`, `maker.maker.defi.cdp.v2-1-0.1`

### Metadata Hash Requirements

Each metadata artifact MUST include a unique `metadataHash` field that serves as a cryptographic fingerprint of the complete metadata content.

#### Hash Generation Process

1. **Content Preparation**
   - Remove the `metadataHash` field from the metadata object
   - Sort all object keys alphabetically
   - Serialize to canonical JSON format (no whitespace, sorted keys)
   - Ensure consistent field ordering across all metadata artifacts

2. **Hash Calculation**
   - Apply SHA-256 to the canonical JSON string
   - Prefix with `0x` for Ethereum compatibility
   - Result MUST be exactly 64 characters (32 bytes)

3. **Hash Validation**
   - MUST be unique across all metadata artifacts
   - MUST be deterministic for identical content
   - MUST be verifiable by regenerating from content

#### On-Chain Storage via CCIP Off-Chain Read

The `metadataHash` MUST be stored on-chain and referenced via CCIP (Cross-Chain Interoperability Protocol) off-chain read for decentralized metadata retrieval. The specific implementation details are left to implementers.

### Hierarchical Schema System

The standard supports a 5-level hierarchical schema system for organizing contract metadata:

| Level | Domain Pattern | Example | Required Field |
|-------|----------------|---------|----------------|
| 0 | `{variant}.eth` | `{root}.eth` | `ensRoot` |
| 1 | `{project}.{variant}.eth` | `uniswap.cns.eth` | `projectRoot` |
| 2 | `{project}.{category}.{root}.eth` | `uniswap.defi.cns.eth` | `categoryRoot` |
| 3 | `{project}.{category}.{subcategory}.{root}.eth` | `uniswap.defi.amm.cns.eth` | `subcategoryRoot` |
| 4 | `{project}.{category}.{subcategory}.{contract}.{root}.eth` | `uniswap.defi.amm.router.cns.eth` | `contractRoot` |

#### Field Inheritance and Deduplication

The hierarchical system implements four deduplication strategies:

- **Inherit**: Fields inherited from parent levels
- **Override**: Fields overridden at child levels with explicit marking
- **Merge**: Fields merged from multiple parent levels
- **Replace**: Fields that replace inherited values completely

### Category Classifications

The standard defines the following primary categories:

| Category | Description |
|----------|-------------|
| `defi` | Decentralized Finance (AMM, lending, stablecoins, yield farming) |
| `dao` | Decentralized Autonomous Organizations (governance, treasury, voting) |
| `l2` | Layer 2 Solutions (rollups, sidechains, state channels) |
| `infra` | Infrastructure (RPC providers, indexers, oracles) |
| `token` | Token Standards (ERC-20, ERC-721, ERC-1155) |
| `nft` | Non-Fungible Tokens (marketplaces, platforms, tools) |
| `gaming` | Gaming and Virtual Worlds |
| `social` | Social Networks and Communication |
| `identity` | Identity and Authentication |
| `privacy` | Privacy and Anonymity |
| `security` | Security Tools and Services |
| `wallet` | Wallet Applications and Services |
| `analytics` | Analytics and Data Services |
| `rwa` | Real World Assets |
| `supply` | Supply Chain Management |
| `health` | Healthcare Applications |
| `finance` | Traditional Finance Integration |
| `dev` | Developer Tools and Services |
| `art` | Art Platforms and Marketplaces |

### Proxy Contract Support

The standard includes support for the following proxy contract patterns:

| Proxy Type | Description | Key Fields |
|------------|-------------|------------|
| `transparent` | Traditional proxy with admin | `implementationAddress`, `proxyAdmin` |
| `uups` | Universal Upgradeable Proxy Standard | `implementationAddress` |
| `beacon` | Beacon-based upgrade pattern | `implementationAddress` |
| `diamond` | Diamond proxy pattern | `implementationAddress` |
| `minimal` | Clone factory pattern | `implementationAddress` |
| `immutable` | Non-upgradeable contracts | None required |

### Validation Framework

All metadata MUST pass validation against the following criteria:

| Validation Type | Description | Requirements |
|-----------------|-------------|--------------|
| Schema Validation | JSON Schema compliance | MUST conform to schema in [Appendix B](#appendix-b-json-schemas) |
| Canonical ID Validation | Grammar pattern compliance | MUST follow canonical ID grammar |
| Address Validation | Ethereum address format validation | MUST be valid 40-character hex addresses |
| Cross-Reference Validation | Consistency across related metadata | MUST maintain referential integrity |
| Security Validation | Security information completeness | MUST include valid attestation |
| Lifecycle Validation | Status and version consistency | MUST have consistent lifecycle information |

### Security Attestation

All contract metadata MUST include a security attestation that provides cryptographic verification of metadata authenticity and integrity.

#### Attestation Requirements

The attestation MUST include the following fields:

| Field | Type | Description |
|-------|------|-------------|
| `reference` | string | 64-character hex hash of attestation data |
| `schema` | string | URI to attestation schema definition |
| `attester` | string | Address of the authorized attester |
| `timestamp` | string | ISO 8601 timestamp of attestation creation |
| `expiry` | string | Optional expiry timestamp |
| `revocable` | boolean | Whether the attestation can be revoked |
| `revocationStatus` | string | Current status: active, revoked, or expired |

#### Validation Rules

The attestation system MUST enforce:

1. **Schema Compliance**: Attestation MUST conform to the JSON Schema defined in [Appendix B](#appendix-b-json-schemas)
2. **Cryptographic Verification**: Attestation hash MUST match metadata content
3. **Temporal Validation**: Timestamp MUST be valid ISO 8601 format
4. **Status Validation**: Revocation status MUST be one of: active, revoked, expired

### Domain-Based Dependency Naming Conventions

The standard defines hierarchical domain naming conventions for dependency mapping using the ENS domain structure. Dependencies are organized under full domain names with variant-based versioning.

#### Dependency Types

The standard supports three primary dependency categories:

| Dependency Type | Domain Pattern | Example |
|-----------------|----------------|---------|
| Library | `{org}.{protocol}.library.{root}.eth` | `openzeppelin.security.library.{root}.eth` |
| Interface | `{org}.{protocol}.interface.{root}.eth` | `erc20.token.interface.{root}.eth` |
| Implementation | `{org}.{protocol}.{category}.{role}.{root}.eth` | `ens.ens.token.token.{root}.eth` |

#### Dependency Resolution Interface

Compliant systems MUST implement the `IDependencyResolver` interface defined in [Appendix D](#appendix-d-domain-based-dependency-examples) for dependency management.

## Conformance

### Artifact Conformance

A metadata artifact is conformant if it:

- MUST conform to the JSON Schema defined in [Appendix B](#appendix-b-json-schemas)
- MUST include all required fields: `id`, `org`, `protocol`, `category`, `role`, `version`, `chainId`, `addresses`, `metadataHash`
- MUST include a valid security attestation
- MUST pass all validation criteria defined in the Validation Framework section

### Contract/Registry Conformance

A metadata registry contract is conformant if it:

- MUST store metadata hashes and associated CCIP gateway information
- MUST support metadata hash verification
- MUST support attestation management
- SHOULD implement the `IDependencyResolver` interface

### Tooling Conformance

Metadata validation and generation tools are conformant if they:

- MUST validate metadata against the JSON Schema
- MUST validate canonical ID grammar
- MUST check address formats
- MUST perform cross-reference validation
- SHOULD provide migration tools for legacy metadata

## Rationale

The design decisions in this standard are driven by several key principles:

### Canonical ID Grammar

The canonical ID grammar provides a structured, hierarchical naming system that enables uniqueness (each contract has a globally unique identifier), discoverability (IDs encode semantic information about the contract), interoperability (consistent naming across different tools and platforms), and versioning (clear version tracking and evolution).

### Hierarchical Schema System

The 5-level hierarchy enables organization (logical grouping of related contracts), inheritance (shared properties across contract families), scalability (support for complex protocol architectures), and flexibility (accommodates different organizational structures).

### Metadata Hash System

The cryptographic hash system ensures integrity (tamper detection for metadata content), uniqueness (prevents duplicate or conflicting metadata), verification (on-chain verification of metadata authenticity), and decentralization (CCIP-based off-chain storage with on-chain verification).

### Security Attestation Framework

The attestation system provides authenticity (cryptographic proof of metadata validity), accountability (clear attribution of metadata sources), revocation (ability to invalidate outdated or incorrect metadata), and transparency (public verification of attestation status).

### Proxy Contract Support

Comprehensive proxy support addresses complexity (modern DeFi protocols often use proxy patterns), upgradeability (clear documentation of upgrade mechanisms), security (proper handling of implementation contracts), and transparency (clear separation of proxy and implementation concerns).

### Domain-Based Dependency Naming

The hierarchical domain naming system for dependencies enables discoverability (navigate dependency trees through ENS domains), version management (check compatibility across dependency chains), security auditing (trace security implications through dependency chains), and ecosystem integration (automated dependency resolution and cross-protocol compatibility checking).

## Backwards Compatibility and Migration

The standard maintains backward compatibility with existing metadata: files with deprecated `domain` field are automatically migrated, deprecated fields are preserved under `_deprecated`, migration warnings are shown but do not block validation, and legacy aliases are supported for existing implementations.

This ENSIP builds upon several existing standards and protocols:

### ENS Standards
- **ENSIP-1**: Provides the foundational ENS protocol specification
- **ENSIP-2**: Defines ENS offchain resolver capabilities used for metadata retrieval
- **ENSIP-3**: Establishes reverse resolution patterns referenced in metadata

### Ethereum Standards
- **ERC-1967**: Proxy storage slots specification used for proxy contract metadata
- **ERC-2535**: Diamond proxy pattern specification for complex upgradeable contracts
- **EIP-3668**: CCIP read protocol for offchain data retrieval

### Metadata Standards
- **JSON Schema Draft 07**: Provides the validation framework for metadata structure
- **Semantic Versioning**: Establishes version format conventions used in canonical IDs
- **IPFS**: Decentralized storage protocol for metadata artifact hosting

### Related Work
- **OpenZeppelin Contracts**: Provides proxy patterns and security standards referenced in metadata
- **EIP-712**: Structured data hashing used in attestation verification
- **Ethereum Attestation Service**: Provides attestation infrastructure patterns

## Contract Dependency Mapping

### Overview

The ENS Contract Metadata Standard supports comprehensive dependency mapping that organizes contract dependencies using the hierarchical ENS domain structure. This creates discoverable dependency graphs where contracts can find their dependencies, dependents, and related interfaces through ENS domain resolution.

### Dependency Types

The standard defines three primary dependency categories:

#### 1. Library Dependencies
External libraries and frameworks used by contracts, where **name is the variant option**:

```json
{
  "libraries": [
    {
      "name": "v4-9-0",
      "domain": "openzeppelin.security.library.{root}.eth",
      "license": "MIT",
      "critical": true,
      "interfaces": ["IERC20", "IERC165", "AccessControl"]
    }
  ]
}
```

#### 2. Interface Dependencies
Interface definitions and their implementations, where **name is the variant option**:

```json
{
  "interfaces": [
    {
      "name": "v0-8-20",
      "domain": "erc20.token.interface.{root}.eth",
      "implementedBy": ["uniswap.defi.amm.router.{root}.eth"],
      "extends": ["IERC165"]
    }
  ]
}
```

#### 3. Implementation Dependencies
Implementation contracts and their relationships, where **name is the variant option**:

```json
{
  "implementations": [
    {
      "name": "v3-1-0",
      "domain": "uniswap.defi.amm.router.{root}.eth",
      "implements": ["IUniswapV3Router"],
      "dependsOn": ["openzeppelin.security.library.{root}.eth"]
    }
  ]
}
```

### Hierarchical Organization

Dependencies are organized under the full domain name structure:

```
ens.resolver.core.publicresolver.{root}.eth
├── dependencies/
│   ├── libraries/
│   │   └── v4-9-0.openzeppelin.security.library.{root}.eth
│   ├── interfaces/
│   │   ├── v1-0-0.ens.resolver.interface.{root}.eth
│   │   └── v2-0-0.ens.recordset.interface.{root}.eth
│   └── implementations/
│       └── v3-2-0.ens.resolver.core.publicresolver.{root}.eth
└── dependents/
    ├── resolvers/
    │   ├── ens.resolver.core.offchainresolver.{root}.eth
    │   └── ens.resolver.core.multicallresolver.{root}.eth
    └── tools/
        ├── ens-subgraph.indexing.tools.{root}.eth
        └── abi-inspector.indexing.tools.{root}.eth
```

### Dependency Resolution Interface

The standard defines interfaces for dependency management that MUST be implemented by compliant systems.

### Benefits

#### For Developers
Developers benefit from **Easy Discovery** (finding compatible libraries and interfaces through ENS domains), **Version Management** (checking compatibility before upgrades), and **Integration Support** (understanding how contracts work together).

#### For Security Auditors
Security auditors benefit from **Dependency Tracing** (following security implications through dependency chains), **Vulnerability Assessment** (identifying vulnerable dependencies across the ecosystem), and **Compliance Checking** (verifying security standards across complex dependency graphs).

#### For Protocol Maintainers
Protocol maintainers benefit from **Upgrade Coordination** (planning upgrades that affect dependent contracts), **Compatibility Testing** (ensuring changes do not break ecosystem compatibility), and **Documentation** (auto-generating comprehensive dependency documentation).

## Fee System

The standard may include fee mechanisms to support sustainable operation. Specific fee structures and economic models are left to implementers.

## Security Considerations

### Attestation Requirements

All contract metadata MUST include an attestation reference that provides cryptographic verification of the metadata authenticity and integrity.

#### Attestation Schema Definition

The attestation schema MUST be explicitly defined and referenced in the metadata:

```json
{
  "security": {
    "attestation": {
      "reference": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
      "schema": "https://schemas.ens.domains/contract-metadata-attestation/v1.0.0",
      "attester": "0x1234567890123456789012345678901234567890",
      "timestamp": "2023-06-15T00:00:00Z",
      "expiry": "2024-06-15T00:00:00Z",
      "revocable": true,
      "revocationStatus": "active"
    }
  }
}
```

#### Attestation Schema Inheritance

Metadata schemas can inherit from attestation schemas to ensure consistency:

```json
{
  "$schema": "https://schemas.ens.domains/contract-metadata/v1.0.0",
  "attestationSchema": {
    "inherits": "https://schemas.ens.domains/contract-metadata-attestation/v1.0.0",
    "extends": {
      "required": ["id", "org", "protocol", "category", "role", "version", "chainId", "addresses"],
      "properties": {
        "security": {
          "allOf": [
            { "$ref": "https://schemas.ens.domains/contract-metadata-attestation/v1.0.0#/definitions/attestation" },
            {
              "properties": {
                "audits": { "type": "array" },
                "owners": { "type": "array" },
                "upgradeability": { "type": "string" }
              }
            }
          ]
        }
      }
    }
  }
}
```

#### Attestation Validation Rules

1. **Reference Validation**
   - Attestation reference MUST be a valid 64-character hex string
   - Reference MUST correspond to a verifiable attestation on-chain
   - Reference MUST be unique within the metadata registry

2. **Schema Validation**
   - Schema URI MUST be accessible and return valid JSON Schema
   - Schema MUST define the structure of the attestation data
   - Schema version MUST be specified and compatible

3. **Attester Validation**
   - Attester address MUST be a valid Ethereum address
   - Attester MUST be authorized to issue attestations for the contract
   - Attester credentials MUST be verifiable

4. **Timestamp Validation**
   - Timestamp MUST be in ISO 8601 format
   - Timestamp MUST be within reasonable bounds (not future-dated)
   - Expiry timestamp MUST be after creation timestamp

5. **Status Validation**
   - Revocation status MUST be one of: active, revoked, expired
   - Revoked attestations MUST include revocation transaction hash
   - Expired attestations MUST be clearly marked

#### Attestation Schema Examples

**Basic Contract Attestation Schema**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Contract Metadata Attestation",
  "type": "object",
  "required": ["contractAddress", "metadataHash", "attester", "timestamp"],
  "properties": {
    "contractAddress": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$"
    },
    "metadataHash": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{64}$"
    },
    "attester": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    },
    "expiry": {
      "type": "string",
      "format": "date-time"
    },
    "revocable": {
      "type": "boolean"
    }
  }
}
```

**Proxy Contract Attestation Schema**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Proxy Contract Metadata Attestation",
  "type": "object",
  "required": ["proxyAddress", "implementationAddress", "metadataHash", "attester", "timestamp"],
  "properties": {
    "proxyAddress": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$"
    },
    "implementationAddress": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$"
    },
    "metadataHash": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{64}$"
    },
    "attester": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    },
    "proxyType": {
      "type": "string",
      "enum": ["transparent", "uups", "beacon", "diamond", "minimal", "immutable"]
    }
  }
}
```

#### Attestation Verification

Attestation verification mechanisms must be implemented by compliant systems to ensure metadata integrity and authenticity.

### Metadata Integrity

All metadata files MUST be cryptographically signed, addresses MUST be validated against on-chain deployments, proxy implementations MUST be verified, security audit information MUST be current and verifiable, and attestation references MUST be verifiable on-chain.

### Access Control

Metadata updates require proper authorization, deprecated metadata MUST be marked as such, security-sensitive information MUST be properly protected, and attestation issuance requires authorized attester credentials.

### Validation Requirements

All metadata MUST pass automated validation, security audits MUST be current (within 12 months), proxy implementations MUST be verified, address integrity MUST be maintained, and attestation references MUST be valid and non-revoked.

## Implementation Guidance

This section provides detailed guidance for implementing the ENS Contract Metadata Standard.

### Metadata Registry Contract

Implementers MUST deploy a metadata registry contract that stores metadata hashes and associated CCIP gateway information. The registry MUST support metadata hash verification, gateway configuration, and attestation management.

#### Registry Implementation Pattern

```solidity
contract MetadataRegistry is IMetadataRegistry {
    using ENSMetadataTypes for *;
    
    mapping(bytes32 => ENSMetadataTypes.MetadataRecord) public records;
    mapping(address => bool) public authorizedAttesters;
    
    function registerMetadata(
        bytes32 node,
        bytes32 metadataHash,
        string calldata gateway,
        string calldata path
    ) external onlyAuthorizedAttester {
        require(records[node].metadataHash == bytes32(0), "Already registered");
        
        records[node] = ENSMetadataTypes.MetadataRecord({
            metadataHash: metadataHash,
            gateway: gateway,
            path: path,
            timestamp: block.timestamp,
            attester: msg.sender,
            active: true,
            chainId: block.chainid
        });
        
        emit MetadataRegistered(node, metadataHash, msg.sender);
    }
    
    function verifyMetadata(bytes32 node, bytes32 metadataHash) 
        external view returns (bool) {
        return records[node].metadataHash == metadataHash && records[node].active;
    }
}
```

#### Gas Optimization Considerations

- Use `bytes32` for metadata hashes to minimize storage costs
- Implement batch operations for multiple metadata registrations
- Use events for metadata change notifications instead of storage
- Consider using CREATE2 for deterministic contract addresses

### CCIP Integration

Implementers MUST integrate with CCIP (Cross-Chain Interoperability Protocol) for offchain metadata retrieval. The implementation MUST support gateway configuration, path resolution, and fallback mechanisms.

#### CCIP Resolver Implementation

```solidity
contract MetadataResolver is IMetadataResolver {
    using ENSMetadataTypes for *;
    
    MetadataRegistry public registry;
    mapping(bytes32 => string) public gateways;
    
    function resolve(
        bytes calldata name,
        bytes calldata data
    ) external view returns (bytes memory) {
        bytes32 node = keccak256(name);
        ENSMetadataTypes.MetadataRecord memory record = registry.records(node);
        
        if (record.metadataHash == bytes32(0)) {
            return "";
        }
        
        // Return CCIP gateway information
        return abi.encode(
            record.gateway,
            record.path,
            record.metadataHash
        );
    }
    
    function setGateway(bytes32 node, string calldata gateway) 
        external onlyOwner {
        gateways[node] = gateway;
        emit GatewayUpdated(node, gateway);
    }
}
```

### Validation Framework

Implementers MUST provide validation tools that verify metadata against the JSON Schema, validate canonical ID grammar, check address formats, and perform cross-reference validation.

#### Validation Contract Pattern

```solidity
contract MetadataValidator is IMetadataValidator {
    using ENSMetadataTypes for *;
    
    function validateMetadata(
        bytes calldata metadata
    ) external view returns (bool valid, string memory error) {
        try this.validateSchema(metadata) returns (bool schemaValid) {
            if (!schemaValid) {
                return (false, "Schema validation failed");
            }
        } catch {
            return (false, "Schema validation error");
        }
        
        try this.validateCanonicalId(metadata) returns (bool idValid) {
            if (!idValid) {
                return (false, "Canonical ID validation failed");
            }
        } catch {
            return (false, "Canonical ID validation error");
        }
        
        return (true, "");
    }
    
    function validateSchema(bytes calldata metadata) 
        external pure returns (bool) {
        // Implement JSON Schema validation logic
        // This would typically involve off-chain validation
        return true;
    }
    
    function validateCanonicalId(bytes calldata metadata) 
        external pure returns (bool) {
        // Implement canonical ID grammar validation
        // Check format: {org}.{protocol}.{category}.{role}.{version}.{chainId}
        return true;
    }
}
```

### Attestation System

Implementers MUST support cryptographic attestation of metadata authenticity. The system MUST handle attestation issuance, verification, revocation, and status tracking.

#### Attestation Implementation

```solidity
contract AttestationManager {
    using ENSMetadataTypes for *;
    
    mapping(bytes32 => ENSMetadataTypes.Attestation) public attestations;
    mapping(bytes32 => bool) public revokedAttestations;
    
    function createAttestation(
        bytes32 metadataHash,
        bytes calldata signature
    ) external onlyAuthorizedAttester {
        bytes32 attestationId = keccak256(abi.encodePacked(
            metadataHash,
            msg.sender,
            block.timestamp
        ));
        
        attestations[attestationId] = ENSMetadataTypes.Attestation({
            hash: keccak256(abi.encodePacked(metadataHash, msg.sender)),
            attester: msg.sender,
            timestamp: block.timestamp,
            signature: signature,
            algorithm: "ECDSA"
        });
        
        emit AttestationCreated(attestationId, metadataHash, msg.sender);
    }
    
    function verifyAttestation(bytes32 attestationId) 
        external view returns (bool) {
        ENSMetadataTypes.Attestation memory att = attestations[attestationId];
        return att.attester != address(0) && !revokedAttestations[attestationId];
    }
    
    function revokeAttestation(bytes32 attestationId) 
        external onlyAuthorizedAttester {
        revokedAttestations[attestationId] = true;
        emit AttestationRevoked(attestationId);
    }
}
```

### Proxy Contract Support

Implementers MUST provide comprehensive support for proxy contract patterns including transparent proxies, UUPS proxies, beacon proxies, diamond proxies, and minimal proxies.

#### Proxy Detection Implementation

```solidity
contract ProxyDetector {
    using ENSMetadataTypes for *;
    
    function detectProxyType(address contractAddress) 
        external view returns (string memory proxyType, address implementation) {
        
        // Check for Transparent Proxy (ERC-1967)
        try IERC1967(contractAddress).implementation() returns (address impl) {
            if (impl != address(0)) {
                return ("transparent", impl);
            }
        } catch {}
        
        // Check for UUPS Proxy
        try IERC1967(contractAddress).implementation() returns (address impl) {
            if (impl != address(0)) {
                // Additional checks for UUPS-specific patterns
                return ("uups", impl);
            }
        } catch {}
        
        // Check for Beacon Proxy
        try IBeacon(contractAddress).implementation() returns (address impl) {
            if (impl != address(0)) {
                return ("beacon", impl);
            }
        } catch {}
        
        // Check for Diamond Proxy
        try IDiamond(contractAddress).facets() returns (bytes4[] memory) {
            return ("diamond", contractAddress);
        } catch {}
        
        // Check for Minimal Proxy (Clone)
        bytes memory code = contractAddress.code;
        if (code.length == 45 && code[0] == 0x36) {
            return ("minimal", address(0));
        }
        
        return ("immutable", address(0));
    }
}
```

### Security Best Practices

#### Access Control Implementation

```solidity
contract SecureMetadataRegistry {
    using ENSMetadataTypes for *;
    
    mapping(address => bool) public authorizedAttesters;
    mapping(address => uint256) public attesterReputation;
    uint256 public constant MIN_REPUTATION = 100;
    
    modifier onlyAuthorizedAttester() {
        require(
            authorizedAttesters[msg.sender] && 
            attesterReputation[msg.sender] >= MIN_REPUTATION,
            "Unauthorized attester"
        );
        _;
    }
    
    function updateAttesterReputation(
        address attester,
        int256 reputationChange
    ) external onlyOwner {
        if (reputationChange > 0) {
            attesterReputation[attester] += uint256(reputationChange);
        } else {
            uint256 decrease = uint256(-reputationChange);
            if (attesterReputation[attester] >= decrease) {
                attesterReputation[attester] -= decrease;
            } else {
                attesterReputation[attester] = 0;
            }
        }
        
        emit ReputationUpdated(attester, attesterReputation[attester]);
    }
}
```

### Testing Strategies

#### Unit Testing Framework

```solidity
contract MetadataRegistryTest {
    using ENSMetadataTypes for *;
    
    MetadataRegistry public registry;
    
    function setUp() public {
        registry = new MetadataRegistry();
    }
    
    function testMetadataRegistration() public {
        bytes32 node = keccak256("test.contract.eth");
        bytes32 metadataHash = keccak256("metadata");
        
        registry.registerMetadata(
            node,
            metadataHash,
            "https://gateway.example.com",
            "/metadata/test.json"
        );
        
        assertTrue(registry.verifyMetadata(node, metadataHash));
    }
    
    function testAttestationVerification() public {
        // Test attestation creation and verification
        bytes32 attestationId = keccak256("test-attestation");
        
        // Create attestation
        registry.createAttestation(keccak256("metadata"), "signature");
        
        // Verify attestation
        assertTrue(registry.verifyAttestation(attestationId));
    }
}
```

### Migration Tools

Implementers MUST provide migration tools for converting existing metadata to the ENSIP-X format, handling deprecated fields, and maintaining backward compatibility.

#### Migration Contract Pattern

```solidity
contract MetadataMigrator {
    using ENSMetadataTypes for *;
    
    mapping(bytes32 => bool) public migratedRecords;
    
    function migrateLegacyMetadata(
        bytes32 node,
        bytes calldata legacyMetadata
    ) external onlyOwner {
        require(!migratedRecords[node], "Already migrated");
        
        // Parse legacy metadata format
        LegacyMetadata memory legacy = abi.decode(legacyMetadata, (LegacyMetadata));
        
        // Convert to new format
        ENSMetadataTypes.ContractMetadata memory newMetadata = convertMetadata(legacy);
        
        // Register new metadata
        registry.registerMetadata(
            node,
            keccak256(abi.encode(newMetadata)),
            legacy.gateway,
            legacy.path
        );
        
        migratedRecords[node] = true;
        emit MetadataMigrated(node, legacy.id, newMetadata.id);
    }
    
    function convertMetadata(LegacyMetadata memory legacy) 
        internal pure returns (ENSMetadataTypes.ContractMetadata memory) {
        // Implementation of legacy to new format conversion
        return ENSMetadataTypes.ContractMetadata({
            id: legacy.id,
            org: legacy.org,
            protocol: legacy.protocol,
            category: legacy.category,
            role: legacy.role,
            version: legacy.version,
            chainId: legacy.chainId,
            addresses: legacy.addresses,
            metadataHash: bytes32(0), // Will be set by registry
            ensRoot: legacy.ensRoot,
            standards: convertStandards(legacy.standards),
            security: convertSecurity(legacy.security),
            deployment: convertDeployment(legacy.deployment),
            subdomains: legacy.subdomains,
            dns: convertDNS(legacy.dns)
        });
    }
}
```

## Governance

### Metadata Stewardship

Metadata stewardship under this standard ensures sustained accuracy, relevance, and trust in contract metadata. The stewardship process actively facilitates the introduction and vetting of new metadata categories, guides the controlled deprecation of obsolete or insecure metadata, manages schema evolution with clear versioning and migration paths, and empowers the ENS community to propose, review, and expand categories. Stewards (no to be confused with working group) are responsible for maintaining best practices, monitoring for outdated or erroneous information, engaging with developers on needed updates, and publishing regular standardized reports detailing changes and rationale.

### Update Process

The metadata update process is governed by a rigorous and transparent protocol to ensure quality, broad participation, and auditability. The workflow comprises these key stages:

1. **Proposal Submission**: Any community member, developer, or steward may submit proposed metadata changes using ENS governance mechanisms. Proposals MUST include detailed rationale, technical impact, and are made public by opening a discussion topic on the ENS DAO forum. Proposals and feedback MUST utilize standardized REQUEST FOR COMMENT (RFC) style templates.

2. **Public Review and Comment**: Each proposal enters a mandatory public review period of at least two weeks, allowing all stakeholders to scrutinize, question, and propose alternative approaches. Advance notice (ideally at least six weeks before potential adoption) SHOULD be given for substantive or contentious updates to enable meaningful community engagement.

3. **Technical Assessment and Testing**: Proposals that pass initial review are subject to robust testing in dedicated environments, including extensive validation, backward-compatibility checks, and comprehensive security assessment by relevant contributors or auditors.

4. **Formal Adoption, Deployment, and Migration**: Once successfully reviewed and tested, proposals are ratified through formal ENS governance. Implementation includes deployment of finalized changes, provision of migration guides, and development of tools to support seamless transition for integrators and users. Amendments to the standard that postdate the initial specification MUST be adopted through executable governance proposals.

5. **Ongoing Documentation and Record Keeping**: All proposals, discussions, reviews, and final decisions are permanently documented, cross-referenced, and maintained within official ENS documentation repositories to ensure traceability, transparency, and community education.


## Migration Guide

### From Legacy Metadata

1. Install compliant metadata tools
2. Run migration process for existing metadata
3. Validate migrated metadata
4. Update references to new canonical IDs

### Schema Updates

1. Backup existing metadata
2. Run schema update process
3. Validate updated metadata
4. Deploy updated metadata

### Quality Assurance Standards

The standard defines quality assurance requirements that must be implemented by compliant systems to ensure metadata integrity and consistency.

### Proxy Contract Specifications

The standard includes detailed proxy contract handling:

#### Supported Proxy Types
The standard supports **Transparent Proxy** (ERC-1967 with separate admin), **UUPS Proxy** (Universal Upgradeable Proxy Standard), **Beacon Proxy** (beacon-based upgrade pattern), **Diamond Proxy** (ERC-2535 Diamond pattern), **Minimal Proxy** (clone factory pattern), and **Immutable** (non-upgradeable contracts).

#### Proxy Naming Conventions
```
{role}.{protocol}.{category}.{root}.eth          # Main proxy contract
{role}-impl.{protocol}.{category}.{root}.eth     # Implementation contract
{role}-admin.{protocol}.{category}.{root}.eth     # Admin contract (transparent only)
```

#### Proxy Validation Rules
Implementation address is required for all proxy types except immutable, admin address is required for transparent proxies, implementation slot validation is required for ERC-1967 proxies, and naming consistency validation is required across proxy/implementation/admin.

### Ownership Release Handling

Contracts that release ownership require special metadata handling to document the transition from centralized to decentralized control. The standard defines four ownership release types:

| Release Type | Description |
|--------------|-------------|
| Admin Contract Renunciation | Transparent proxy admin contracts that renounce admin privileges |
| Ownership Transfer to Zero Address | Contracts transferring ownership to `0x0000000000000000000000000000000000000000` |
| Multi-signature to Single Signature | Transition from multi-sig control to individual key control |
| Complete Decentralization | Contracts that remove all upgrade mechanisms |

#### Metadata Requirements

Ownership release metadata MUST include:

- Transaction hash and block number for verification
- Previous and new owner addresses
- Release method specification
- Irreversibility confirmation
- Timeline documentation

#### Validation Rules

- Transaction hash MUST be verifiable on-chain
- Block number MUST be specified for historical verification
- Release method MUST be specified (e.g., `renounceOwnership`, `transferOwnership`)
- `irreversible` field MUST be `true` for true ownership release

See [Appendix A](#appendix-a-examples) for complete ownership release examples.

### ENS Operations Integration

The standard integrates with ENS operations:

#### Subdomain Registration
The standard includes owner address validation, resolver configuration, TTL settings (ENSv2), and fuse management (ENSv3).

#### Record Management
The standard supports address records (ETH and multicoin), text records (URL, description, version), content hash records, and reverse resolution support.

#### Fuse System (ENSv3)
The standard defines critical fuses (CANNOT_UNWRAP, CANNOT_BURN_FUSES, CANNOT_TRANSFER), fuse templates (locked, immutable, subdomain-locked, resolver-locked), and permanent security guarantees through burned fuses.

### Compliance Scoring

Compliance scoring mechanisms may be implemented by compliant systems to assess metadata quality and adherence to standards.

### Migration and Backward Compatibility

#### Legacy Support
The standard provides automatic migration from deprecated `domain` field to `category`, preservation of deprecated fields under `_deprecated`, migration warnings that do not block validation, and legacy alias support for existing implementations.

#### Migration Process
Migration processes must be implemented by compliant systems to ensure backward compatibility and smooth transitions.

## Examples

See [Appendix A](#appendix-a-examples) for complete metadata examples including:

- DeFi AMM Contract (Uniswap V3 Router)
- DAO Governance Contract with Proxy (ENS Governor)
- Token Contract (ENS Token)
- Ownership Release Examples (Uniswap V2 Factory, ENS Registry)

## References

[ENSIP-1: ENS](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-137.md), 
[ENSIP-2: ENS Offchain Resolver](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3668.md), 
[ENSIP-3: ENS Reverse Resolution](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-181.md), 
[JSON Schema Draft 07](https://json-schema.org/draft/2019-09/schema),
[ERC-1967: Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967),
[Semantic Versioning](https://semver.org/)

## Appendices

### Appendix A: Examples

#### DeFi AMM Contract

```json
{
  "id": "uniswap.uniswap.defi.router.v3-1-0.1",
  "org": "uniswap",
  "protocol": "uniswap",
  "category": "defi",
  "subcategory": "amm",
  "role": "router",
  "version": "v3-1-0",
  "chainId": 1,
  "addresses": [
    {
      "chainId": 1,
      "address": "0xE592427A0AEce92De3Edee1F18E0157C05861564",
      "deployedBlock": 12369621
    }
  ],
  "metadataHash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
  "ensRoot": "uniswap.defi.{root}.eth",
  "standards": {
    "ercs": ["ERC-20", "ERC-721"],
    "interfaces": ["IUniswapV3SwapCallback"]
  },
  "artifacts": {
    "abiHash": "0x1234567890abcdef...",
    "sourceUri": "https://github.com/Uniswap/v3-core",
    "license": "GPL-3.0"
  },
  "lifecycle": {
    "status": "active",
    "since": "2021-05-05"
  },
  "security": {
    "audits": [
      {
        "firm": "Trail of Bits",
        "date": "2021-03-15",
        "report": "https://uniswap.org/audit-trail-of-bits"
      }
    ],
    "upgradeability": "immutable"
  },
  "tags": ["amm", "dex", "ethereum", "uniswap-v3"]
}
```

#### DAO Governance Contract with Proxy

```json
{
  "id": "ens.ens.dao.governor.v1-0-0.1",
  "org": "ens",
  "protocol": "ens",
  "category": "dao",
  "subcategory": "governance",
  "role": "governor",
  "version": "v1-0-0",
  "chainId": 1,
  "addresses": [
    {
      "chainId": 1,
      "address": "0x323A76393544d5ecca80cd6ef2A560C98a6e9b8E",
      "deployedBlock": 12067752,
      "implementation": "0x0987654321098765432109876543210987654321",
      "implementationSlot": "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
    }
  ],
  "metadataHash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
  "ensRoot": "ens.dao.{root}.eth",
  "standards": {
    "ercs": ["ERC-20"],
    "interfaces": ["IGovernor"]
  },
  "artifacts": {
    "abiHash": "0xabcdef1234567890...",
    "sourceUri": "https://github.com/ensdomains/governance",
    "license": "MIT"
  },
  "lifecycle": {
    "status": "active",
    "since": "2021-08-17"
  },
  "security": {
    "audits": [
      {
        "firm": "OpenZeppelin",
        "date": "2021-07-20",
        "report": "https://ens.domains/audit-openzeppelin"
      }
    ],
    "upgradeability": "transparent"
  },
  "proxy": {
    "proxyType": "transparent",
    "implementationAddress": "0x0987654321098765432109876543210987654321",
    "implementationSlot": "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
    "proxyAdmin": "0x1234567890123456789012345678901234567890",
    "proxyVersion": "v1-0-0"
  },
  "tags": ["dao", "governance", "ens", "ethereum", "proxy"]
}
```

#### Token Contract Example

```json
{
  "id": "ens.ens.token.token.v1-0-0.1",
  "org": "ens",
  "protocol": "ens",
  "category": "token",
  "subcategory": "native",
  "role": "token",
  "version": "v1-0-0",
  "chainId": 1,
  "addresses": [
    {
      "chainId": 1,
      "address": "0xC5dDf9077ca0834C1FaDDED2B2B29Cf0fB5bC8Be",
      "deployedBlock": 12765000
    }
  ],
  "metadataHash": "0xc4167f60a302d0a0bfa11b36b6cd4d59dc38c88621204520fd2fa2c1ae5999a2",
  "ensRoot": "ens.token.{root}.eth",
  "standards": {
    "ercs": ["ERC-20"],
    "interfaces": ["IERC20", "IERC20Metadata"]
  },
  "artifacts": {
    "abiHash": "0xf5e6200cd46e6c2482a5e00cc8bfa1d1a7cf4d7a69b0290e190df9a46fd229ad",
    "sourceUri": "https://github.com/ensdomains/governance-token",
    "license": "MIT"
  },
  "lifecycle": {
    "status": "active",
    "since": "2021-05-04"
  },
  "security": {
    "audits": [
      {
        "firm": "OpenZeppelin",
        "date": "2021-05-10",
        "report": "https://docs.ens.domains/audit-openzeppelin-ens-token"
      }
    ],
    "upgradeability": "immutable"
  },
  "tags": ["ens", "token", "erc-20", "governance", "ethereum"]
}
```

#### Ownership Release Examples

**Uniswap V2 Factory (Admin Renunciation)**
```json
{
  "id": "uniswap.uniswap.defi.factory.v2-0-0.1",
  "security": {
    "upgradeability": "renounced",
    "ownershipStatus": "decentralized",
    "ownershipRelease": {
      "type": "admin-renunciation",
      "date": "2020-05-05T00:00:00Z",
      "transactionHash": "0x1234567890abcdef...",
      "blockNumber": 10000834,
      "previousOwner": "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
      "newOwner": "0x0000000000000000000000000000000000000000",
      "releaseMethod": "renounceOwnership",
      "irreversible": true
    }
  },
  "lifecycle": {
    "status": "immutable",
    "since": "2020-05-05T00:00:00Z",
    "ownershipTransition": {
      "from": "centralized",
      "to": "decentralized",
      "date": "2020-05-05T00:00:00Z"
    }
  }
}
```

**ENS Registry (Ownership Renunciation)**
```json
{
  "id": "ens.ens.registry.core.v1-14-0.1",
  "security": {
    "upgradeability": "renounced",
    "ownershipStatus": "decentralized",
    "ownershipRelease": {
      "type": "admin-renunciation",
      "date": "2022-03-17T00:00:00Z",
      "transactionHash": "0xf43c3eb6e7057c7d4c2da4a2ff61b8c06b8276cfc87aad8447ceaee85f15f6cc",
      "blockNumber": 14398710,
      "previousOwner": "0x22b00123c5f7665fbb1f3509b32f8ce78e54b191",
      "newOwner": "0x0000000000000000000000000000000000000000",
      "releaseMethod": "renounceOwnership",
      "irreversible": true
    }
  },
  "lifecycle": {
    "status": "immutable",
    "since": "2022-03-17T00:00:00Z",
    "ownershipTransition": {
      "from": "centralized",
      "to": "decentralized",
      "date": "2022-03-17T00:00:00Z"
    }
  }
}
```

### Appendix B: JSON Schemas

#### Core Metadata Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ENS Contract Metadata",
  "type": "object",
  "required": [
    "id", "org", "protocol", "category", "role", "version", "chainId", "addresses", "metadataHash"
  ],
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^[a-z0-9.-]+$",
      "description": "Canonical identifier following ENSIP-X grammar"
    },
    "org": {
      "type": "string",
      "pattern": "^[a-z0-9-]+$",
      "description": "Organization identifier (lowercase, hyphen-separated)"
    },
    "protocol": {
      "type": "string",
      "pattern": "^[a-z0-9-]+$",
      "description": "Protocol identifier (lowercase, hyphen-separated)"
    },
    "category": {
      "type": "string",
      "enum": [
        "defi", "dao", "l2", "infra", "token", "nft", "gaming", 
        "social", "identity", "privacy", "security", "wallet", 
        "analytics", "rwa", "supply", "health", "finance", "dev", "art"
      ],
      "description": "Primary category classification"
    },
    "subcategory": {
      "type": "string",
      "description": "Subcategory within the primary category"
    },
    "role": {
      "type": "string",
      "pattern": "^[a-z0-9-]+$",
      "description": "Contract role/function (lowercase, descriptive)"
    },
    "variant": {
      "type": "string",
      "pattern": "^[a-z0-9-]+$",
      "description": "Optional protocol variant identifier"
    },
    "version": {
      "type": "string",
      "pattern": "^v[0-9]+(-[0-9]+)?(-[0-9]+)?$",
      "description": "Version format: v{num}, v{num}-{num}, or v{num}-{num}-{num}"
    },
    "chainId": {
      "type": "integer",
      "minimum": 1,
      "description": "Target blockchain network ID"
    },
    "addresses": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["chainId", "address"],
        "properties": {
          "chainId": { "type": "integer" },
          "address": { 
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "deployedBlock": { "type": "integer" },
          "bytecodeHash": { "type": "string" },
          "implementation": { "type": ["string", "null"] },
          "implementationSlot": { "type": "string" }
        }
      }
    },
    "metadataHash": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{64}$",
      "description": "SHA-256 hash of the complete metadata artifact for unique identification and ENS text record reference"
    },
    "ensRoot": {
      "type": "string",
      "pattern": "^[a-z0-9.-]+\\.cns\\.eth$",
      "description": "ENS subdomain root (e.g., uniswap.defi.{root}.eth)"
    },
    "standards": {
      "type": "object",
      "properties": {
        "ercs": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "interfaces": { 
          "type": "array", 
          "items": { "type": "string" }
        }
      }
    },
    "artifacts": {
      "type": "object",
      "properties": {
        "abiHash": { "type": "string" },
        "sourceUri": { "type": "string" },
        "license": { "type": "string" }
      }
    },
    "lifecycle": {
      "type": "object",
      "properties": {
        "status": { "type": "string" },
        "since": { "type": "string" },
        "replacedBy": { "type": "string" }
      }
    },
    "security": {
      "type": "object",
      "properties": {
        "audits": { "type": "array" },
        "owners": { "type": "array" },
        "upgradeability": { "type": "string" },
        "permissions": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "attestation": {
          "type": "object",
          "required": ["reference", "schema"],
          "properties": {
            "reference": {
              "type": "string",
              "pattern": "^0x[a-fA-F0-9]{64}$",
              "description": "Attestation reference hash or transaction hash"
            },
            "schema": {
              "type": "string",
              "description": "URI to attestation schema definition"
            },
            "attester": {
              "type": "string",
              "pattern": "^0x[a-fA-F0-9]{40}$",
              "description": "Address of the attestation issuer"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time",
              "description": "Attestation creation timestamp"
            },
            "expiry": {
              "type": "string",
              "format": "date-time",
              "description": "Attestation expiry timestamp (optional)"
            },
            "revocable": {
              "type": "boolean",
              "description": "Whether the attestation can be revoked"
            },
            "revocationStatus": {
              "type": "string",
              "enum": ["active", "revoked", "expired"],
              "description": "Current status of the attestation"
            }
          }
        }
      }
    },
    "proxy": {
      "type": "object",
      "properties": {
        "proxyType": {
          "type": "string",
          "enum": ["transparent", "uups", "beacon", "diamond", "minimal", "immutable"]
        },
        "implementationAddress": {
          "type": "string",
          "pattern": "^0x[a-fA-F0-9]{40}$"
        },
        "implementationSlot": { "type": "string" },
        "proxyAdmin": {
          "type": "string",
          "pattern": "^0x[a-fA-F0-9]{40}$"
        },
        "proxyVersion": { "type": "string" }
      }
    },
    "tags": { 
      "type": "array", 
      "items": { "type": "string" }
    },
    "subdomains": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["label", "owner"],
        "properties": {
          "label": { "type": "string" },
          "owner": { 
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "controller": { 
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "resolver": { 
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "records": { "type": "object" }
        }
      }
    }
  }
}
```

#### Attestation Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Contract Metadata Attestation",
  "type": "object",
  "required": ["contractAddress", "metadataHash", "attester", "timestamp"],
  "properties": {
    "contractAddress": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$",
      "description": "Ethereum address of the attested contract"
    },
    "metadataHash": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{64}$",
      "description": "SHA-256 hash of the metadata content"
    },
    "attester": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{40}$",
      "description": "Address of the authorized attester"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp of attestation creation"
    },
    "expiry": {
      "type": "string",
      "format": "date-time",
      "description": "Optional expiry timestamp"
    },
    "revocable": {
      "type": "boolean",
      "description": "Whether the attestation can be revoked"
    },
    "revocationStatus": {
      "type": "string",
      "enum": ["active", "revoked", "expired"],
      "description": "Current status of the attestation"
    }
  }
}
```

### Appendix C: Solidity Type Definitions

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title ENS Contract Metadata Types
/// @notice Core data structures for ENS Contract Metadata Standard (ENSIP-X)
library ENSMetadataTypes {
    /// @notice Contract metadata structure as defined in ENSIP-X
    struct ContractMetadata {
        string id;                    // Canonical contract ID
        string org;                   // Organization/project name
        string protocol;              // Protocol name
        string category;              // Contract category (defi, dao, nft, etc.)
        string role;                  // Contract role (router, governor, token, etc.)
        string version;               // Contract version
        uint256 chainId;              // Chain ID where contract is deployed
        address[] addresses;          // Contract addresses across chains
        bytes32 metadataHash;         // SHA-256 hash of full metadata
        string ensRoot;               // ENS root domain for this contract
        Standards standards;          // ERC standards and interfaces
        Security security;            // Security and audit information
        Deployment deployment;        // Deployment and ownership info
        bytes32[] subdomains;         // Related subdomain hashes
        DNS dns;                      // DNS record information
    }

    /// @notice Standards compliance information
    struct Standards {
        string[] ercs;                // ERC standards (erc20, erc721, etc.)
        ContractInterface[] interfaces; // Detailed interface information
        DependencyInfo dependencies;  // Contract dependency information
    }

    /// @notice Interface definition structure
    struct ContractInterface {
        string name;                  // Interface name (IERC20, IUniswapV3Router)
        bytes4 id;                    // ERC-165 interface identifier
        string standard;              // Standard this interface implements
        string version;               // Interface version
        InheritanceInfo inheritance;  // Interface inheritance details
        string[] implemented;         // Functions implemented by contract
        string[] optional;            // Optional functions
        string[] events;              // Events defined by interface
        string[] errors;              // Custom errors defined by interface
        string documentation;         // Interface documentation URL
        string specification;         // Interface specification reference
    }

    /// @notice Interface inheritance information
    struct InheritanceInfo {
        string[] inherits;            // Parent interfaces
        bool required;                // Whether inheritance is required
    }

    /// @notice Contract dependency information
    struct DependencyInfo {
        LibraryDependency[] libraries;    // External libraries used
        InterfaceDependency[] interfaces; // Interface dependencies
        ImplementationDependency[] implementations; // Implementation dependencies
    }

    /// @notice Dependency resolution result
    struct DependencyResolution {
        bool compatible;                  // Whether dependency chain is compatible
        string[] issues;                  // Any compatibility issues found
        DependencyNode[] dependencyGraph; // Full dependency graph
    }

    /// @notice Dependency graph node
    struct DependencyNode {
        string domain;                    // ENS domain of the contract
        string contractType;              // Type: library, interface, implementation
        DependencyEdge[] dependencies;    // Outgoing dependencies
        DependencyEdge[] dependents;      // Incoming dependencies
    }

    /// @notice Dependency graph edge
    struct DependencyEdge {
        string domain;                    // ENS domain of the dependency
        string relationship;              // Type of relationship (uses, implements, extends)
    }

    /// @notice Library dependency information
    struct LibraryDependency {
        string name;                      // Variant identifier (e.g., "v4-9-0")
        string domain;                    // Base ENS domain for library metadata
        string license;                   // Library license
        bool critical;                    // Whether this is a critical dependency
        string[] interfaces;              // Interfaces provided by this library
    }

    /// @notice Interface dependency information
    struct InterfaceDependency {
        string name;                      // Variant identifier (e.g., "v0-8-20")
        string domain;                    // Base ENS domain for interface metadata
        string[] implementedBy;           // Contracts implementing this interface
        string[] extends;                 // Interfaces this interface extends
    }

    /// @notice Implementation dependency information
    struct ImplementationDependency {
        string name;                      // Variant identifier (e.g., "v3-1-0")
        string domain;                    // Base ENS domain for implementation metadata
        string[] implements;              // Interfaces this implementation implements
        string[] dependsOn;               // Dependencies this implementation has
    }

    /// @notice Security and audit information
    struct Security {
        Attestation attestation;      // Cryptographic attestation
        AuditInfo[] audits;           // Security audit results
        bool verified;                // Whether contract is verified
        string verificationSource;    // Source of verification
    }

    /// @notice Cryptographic attestation structure
    struct Attestation {
        bytes32 hash;                 // Hash of attestation data
        address attester;             // Address that created attestation
        uint256 timestamp;            // Attestation timestamp
        bytes signature;              // Attester signature
        string algorithm;             // Signature algorithm used
    }

    /// @notice Security audit information
    struct AuditInfo {
        string auditor;               // Audit firm/company
        string report;                // Audit report URL or hash
        uint256 date;                 // Audit completion date
        string[] findings;            // Critical findings summary
        bool passed;                  // Whether audit passed
    }

    /// @notice Deployment and ownership information
    struct Deployment {
        uint256 deploymentDate;       // Contract deployment timestamp
        address deployer;             // Address that deployed contract
        address owner;                // Current contract owner
        OwnershipInfo ownership;      // Detailed ownership information
        string upgradeability;        // Upgrade mechanism (transparent, uups, etc.)
        PermissionInfo permissions;   // Permission and access control
    }

    /// @notice Ownership information for multisig/governance
    struct OwnershipInfo {
        OwnerInfo[] owners;           // List of owners
        string governance;            // Governance mechanism
        MultisigInfo multisig;        // Multisig configuration if applicable
    }

    /// @notice Individual owner information
    struct OwnerInfo {
        address addr;                 // Owner address
        string entityType;            // Type: eoa, multisig, dao, contract, etc.
        string name;                  // Owner name/identifier
        bool ownershipReleased;       // Whether ownership was released
    }

    /// @notice Multisig configuration
    struct MultisigInfo {
        address contract;             // Multisig contract address
        string version;               // Multisig version
        uint256 threshold;            // Required signatures
        GnosisSafeInfo gnosisSafe;    // Gnosis Safe specific info if applicable
    }

    /// @notice Gnosis Safe specific information
    struct GnosisSafeInfo {
        address fallbackHandler;      // Fallback handler contract
        address guard;                // Guard contract for validation
        address[] modules;            // Enabled modules
    }

    /// @notice Permission and access control information
    struct PermissionInfo {
        string[] roles;               // Role definitions
        address[] admins;             // Admin addresses
        bool pausable;                // Whether contract can be paused
        bool upgradable;              // Whether contract can be upgraded
    }

    /// @notice Subdomain information
    struct SubdomainInfo {
        bytes32 node;                 // ENS namehash of subdomain
        string name;                  // Subdomain name
        address resolver;             // Subdomain resolver
        uint64 ttl;                   // Time to live
        RecordInfo[] records;         // DNS records
    }

    /// @notice DNS record information
    struct RecordInfo {
        string recordType;            // DNS record type (A, AAAA, CNAME, etc.)
        string value;                 // Record value
        uint64 ttl;                   // Record TTL
    }

    /// @notice Complete DNS configuration
    struct DNS {
        SubdomainInfo[] subdomains;   // Subdomain configurations
        RecordInfo[] records;         // DNS records
    }

    /// @notice Metadata registry record
    struct MetadataRecord {
        bytes32 metadataHash;         // SHA-256 hash of metadata
        string gateway;               // CCIP gateway URL
        string path;                  // Path to metadata file
        uint256 timestamp;            // Last update timestamp
        address attester;             // Attestation issuer
        bool active;                  // Record status
        uint256 chainId;              // Source chain ID for cross-chain records
    }

    /// @notice Contract categories as defined in ENSIP-X
    enum ContractCategory {
        DEFI,           // DeFi protocols
        DAO,            // Decentralized Autonomous Organizations
        NFT,            // Non-Fungible Tokens
        DEX,            // Decentralized Exchanges
        LENDING,        // Lending protocols
        BRIDGE,         // Cross-chain bridges
        ORACLE,         // Price oracles
        GOVERNANCE,     // Governance contracts
        UTILITY,        // Utility contracts
        GAMEFI,         // GameFi protocols
        IDENTITY,       // Identity solutions
        INFRASTRUCTURE, // Infrastructure protocols
        STABLECOIN,     // Stablecoin contracts
        YIELD,          // Yield farming protocols
        INSURANCE,      // Insurance protocols
        PRIVACY,        // Privacy protocols
        ANALYTICS,      // Analytics protocols
        RWA,            // Real World Assets
        SUPPLY,         // Supply Chain Management
        HEALTH,         // Healthcare Applications
        FINANCE,        // Traditional Finance Integration
        DEV,            // Developer Tools and Services
        ART             // Art Platforms and Marketplaces
    }
}
```

### Appendix D: Domain-Based Dependency Examples

#### Dependency Resolution Interface

```solidity
interface IDependencyResolver {
    /// Get all dependencies for a contract
    function getContractDependencies(bytes32 node)
        external view returns (DependencyInfo[] memory dependencies);

    /// Get all contracts that depend on this contract
    function getContractDependents(bytes32 node)
        external view returns (DependentInfo[] memory dependents);

    /// Check if dependency chain is compatible
    function verifyDependencyChain(bytes32[] memory dependencyChain)
        external view returns (bool compatible, string[] memory issues);

    /// Get dependency graph for a contract
    function getDependencyGraph(bytes32 node, uint256 depth)
        external view returns (DependencyNode[] memory graph);
}
```

#### Dependency Domain Examples

**ENS Token Contract Dependencies:**
```
ens.ens.token.token.{root}.eth
├── dependencies/
│   ├── libraries/
│   │   └── v4-9-0.openzeppelin.security.library.{root}.eth
│   ├── interfaces/
│   │   ├── v0-8-20.erc20.token.interface.{root}.eth
│   │   └── v3-0-0.ens.base.interface.{root}.eth
│   └── implementations/
│       └── v1-0-0.ens.ens.token.token.{root}.eth
└── dependents/
    ├── resolvers/
    │   ├── publicresolver.ens.resolver.core.{root}.eth
    │   └── offchainresolver.ens.resolver.core.{root}.eth
    └── tools/
        └── ens-token-subgraph.indexing.tools.{root}.eth
```

### Appendix E: Change Log

#### Version 1.0.0 (2024-10-15)

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

## References

[ENSIP-1: ENS](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-137.md), 
[ENSIP-2: ENS Offchain Resolver](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3668.md), 
[ENSIP-3: ENS Reverse Resolution](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-181.md), 
[JSON Schema Draft 07](https://json-schema.org/draft/2019-09/schema),
[ERC-1967: Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967),
[Semantic Versioning](https://semver.org/)

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
