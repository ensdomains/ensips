---
description: Introduces coinType for EVM compatible chains (amending ENSIP9).
contributors:
  - matoken.eth
  - Teddy (@0xteddybear)
  - Joxes (@0xJoxess)
  - Skeletor Spaceman (@skeletor-spaceman)
  - Racu (@0xRacoon)
  - TiTi (@0xtiti)
  - Gori (@0xGorilla)
  - Ardy (@0xArdy)
  - Onizuka (@onizuka-wl)
ensip:
  status: final
  created: 2022-01-13
requires: ERC-7930, CAIP-350
---

# ENSIP-11: EVM compatible Chain Address Resolution

Introduces coinType for EVM compatible chains (amending [ENSIP-9](https://docs.ens.domains/ensip/9)).

## Abstract

This ENSIP extends [ENSIP 9 (multichain address resolution)](./9), deprecating separate addresses and coin types in favor of [ERC-7930] Interoperable Addresses.

## Motivation

The existing ENSIP 9 relies on the existence of coin types on [SLIP44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md) which was designed to define address encoding type for deterministic wallets. As the majority of EVM compatible chains inherit the same encoding type as Ethereum, it is redundant to keep requesting the addition of EVM compatible chains into SLIP 44. This specification integrates ENS with Interoperable Addresses as defined in [ERC-7930], which are a single payload including both the address and the chain on which that address belongs.

## Specification

This specification amends ENSIP 9 to allow resolvers to use a `bytes` parameter, which should be an Interoperable Address containing only a chain specification, and returns an Interoperable Address containing only an address
<!-- TODO: it could be a complete Interoperable Address, costing a bit more gas -->

```solidity
function addr(bytes32 node, bytes memory chain) external view returns (bytes memory address_)
```

Where:
- `bytes32 node` is the namehash of the name to be resolved, as defined in ENSIP-1.
- `bytes memory chain` is a v1-compatible Interoperable Addresses describing the chain on which the address returned will live. Its `address` field must be empty.
- `bytes memory address_` is a v1-compatible Interoperable Addresses describing the resulting address. Its `ChainReference` field must be empty.

### Example

To query the address of `vitalik.eth` on OP Mainnet

- `node`: `namehash(vitalik.eth) == 0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835`
- `chain`: `0x00010000010A` (version 1, chain namespace `0000 == eip155`, `ChainReferenceLength == 1`, `ChainReference == 10`)

### Backwards Compatibility

#### Exceptions

The following EVM chains are the exception to this standard.

* AVAX = AVAX has multiple chain address formats, and only c chain is EVM compatible
* RSK = RSK has its own additional validation

They will continue using coinType defined at SLIP44

#### ENSIP-9

The following EVM compatible cointypes existed before introducing any versions of this standard.

* NRG
* POA
* TT
* CELO
* CLO
* TOMO
* EWT
* THETA
* GO
* FTM
* XDAI
* ETC

When you display them for backward compatibility purposes, append `_LEGACY` to the cointype and make them read only.

If defined, the CAIP-350 profile of a chain's address serialization scheme takes precedence over the one defined in ENSIP-9

#### Previous versions of this same standard
Resolution of pre-existing `uint256 coinType`s can be supported since there's a clear bijectivity with chains as defined in ERC-7930. 

`type(uint32).max / 2 < coinType <= type(uint32).max`
: remove up to three bytes, starting from the most significative, if they are zero and produce an `eip155` Interoperable Address with that as the chain reference.

`coinType > type(uint32).max`
: Error case, not supported by previous versions of ENSIP-11 or ENSIP-9.

`0 coinType <= type(uint32).max / 2`
: use an internal lookup table to convert existing supported `coinType`s to the appropiate Interoperable Address
<!-- alternative: proceed with legacy ENSIP-9 resolution -->

<!-- TODO: define precedence of writing and reading legacy cointypes vs those defined in this standard. Ideally: 
- if ENSIP-9 is already defined, that value should be read
- it's an error to define a non-zero ENSIP-9 style name 
- if ENSIP-9 is already defined, it's an error to write an equivalent ENSIP-11
-->

## Rationale
- Backwards-compatibility of this standard can easily be defined in code, needing no manual migrations by users.
- Using an arbitrary-length `bytes` allows for future compatibility with chainids longer than 32 bits (e.g. in the case the output from a hash function is used, as proposed by ERC-7785) and with chains on CASA namespaces other than `eip155`.
- Leaning on CAIP-350 and ERC-7930 for the serialization details of every chain's addresses allows this standard to stay lean and don't define all the possible chain formats it may possibly support.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

<!-- TODO: link to spec permalink once it's an official draft -->
[ERC-7930]: https://github.com/ethereum/ERCs/pull/1002
<!-- TODO: link to spec permalink once it's an official draft -->
[CAIP-350]: https://github.com/ChainAgnostic/CAIPs/blob/892cbe8525028469f31dc4b1eb201fe5419194bb/CAIPs/caip-350.md
[ENSIP-9]: ./9
[ENSIP-1]: ./1
