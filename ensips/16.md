---
description: Allows metadata to be queried on EIP-3668 enabled names
contributors:
  - jefflau
  - matoken.eth
ensip:
  status: draft
  created: 2022-09-22
  updated: 2025-08-04
ignoredRules: ["heading:implementation", "heading:open-items"]
---

# ENSIP-16: Metadata

## Abstract

This ENSIP specifies APIs for querying metadata directly on the resolver for EIP-3668 (CCIP Read: Secure offchain data retrieval) enabled names. EIP-3668 will power many of the domains in the future, however since the retrieval mechanism uses wildcard + offchain resolver, there is no standardised way to retrieve important metadata information such as the owner (who can change the records), or which L2/offchain database the records are stored on.

## Motivation

With EIP-3668 subdomains already starting to see wide adoption, it is important that there is a standardised way for different stakeholders to discover and access metadata about offchain names.

This ENSIP addresses three critical use cases:

**Frontend Developers**: This ENSIP provides a standardised interface to discover endpoints that clients can query for metadata about any name. Frontend applications can retrieve essential information—such as who can modify records and where data is stored—without needing to understand the underlying storage implementation details. This enables UIs to check permissions (e.g., whether the connected user can update a name) and provide a smooth user experience across all offchain name systems.

**Data Indexers**: Third-party indexing services can use the `MetadataChanged` event to automatically discover which chain and smart contract address will emit metadata events. This allows indexers to dynamically discover new data sources and begin indexing them without manual configuration, enabling comprehensive coverage of the ENS ecosystem.

**Name Owners with Custom Storage**: For name owners who store records in traditional databases (RDBMS) or non-EVM compatible chains, this ENSIP provides a way to expose metadata through a common GraphQL interface. This allows these systems to present metadata in the same format as EVM-based implementations without exposing implementation details, ensuring compatibility with existing tooling and clients.

This ENSIP does not address how the metadata is constructed so that the name owners with custom storage can define their own method.

## Specification

Metadata serves a crucial role in providing valuable insights about a node owner and their specific resolver. In certain scenarios, resolvers may choose to adopt diverse approaches to resolve data based on the node. An example of this would be handling subdomains of a particular node differently. For instance, we could resolve "optimism.foo.eth" using a contract on optimism and "gnosis.foo.eth" using a contract on gnosis.
By passing the name through metadata, we empower the resolution process, enabling CcipResolve flows to become remarkably flexible and scalable. This level of adaptability ensures that our system can accommodate a wide array of use cases, making it more user-friendly and accommodating for a diverse range of scenarios.

## Implementation

### Interface

```solidity
// To be included in
// https://github.com/ensdomains/ens-contracts/blob/staging/contracts/resolvers/Resolver.sol
interface IOffchainResolverMetadataProvider {

    /**
     * @dev Returns metadata for discovering the location of offchain name data
     * @param name DNS-encoded name to query
     * @return graphqlUrl The GraphQL endpoint for querying offchain data
     * @return chainId The chain ID where the data is stored (0 for non-EVM sources)
     * @return l2RegistryAddress The root registry address on the target chain
     */
    function metadata(bytes calldata name)
        external
        view
        returns (
            string memory graphqlUrl,
            uint256 chainId,
            address l2RegistryAddress
        );

    // Optional. If context is dynamic, the event won't be emitted.
    event MetadataChanged(
        bytes name,              // DNS-encoded name
        string graphqlUrl,       // GraphQL endpoint for offchain data
        uint256 chainId,         // Chain identifier (0 for non-EVM sources)
        address l2RegistryAddress // Root registry address on target chain
    );
}
```

### metadata function

The metadata function allows resolvers to dynamically provide information about where offchain data for a given name can be queried. This function returns the same information as would be emitted in a MetadataChanged event: the GraphQL endpoint URL, the chain ID where the data resides (0 for non-EVM sources), and the root registry address on the target chain. This enables clients to discover and connect to the appropriate data source for any given name. 

### MetadataChanged Event

The MetadataChanged event allows resolvers to signal where offchain metadata can be queried. When the data is stored on other EVM compatible chains, it can specify chain id and its root registry address so that indexers can dynamically discover the new source and start indexing.

### GraphQL Schema

[GraphQL](https://graphql.org) is a query language for APIs and a runtime for fulfilling those queries with onchain event data. You can use the hosted/decentralised indexing service such as [The Graph](https://thegraph.com), [Goldsky](https://docs.goldsky.com/introduction), [QuickNode](https://marketplace.quicknode.com/add-on/subgraph-hosting) or host your own using The Graph, or [ponder](https://ponder.sh)

#### L1

The following schema should be implemented by indexers to track MetadataChanged events:

```graphql
type Domain @entity {
  id
  metadata: Metadata
}

type Metadata @entity {
  "L1 resolver address"
  id: ID!
  "DNS encoded name"
  name: String
  "URL of the GraphQL endpoint"
  graphqlUrl: String
  "Chain identifier (0 for non-EVM sources)"
  chainId: BigInt
  "Root registry address on target chain"
  l2RegistryAddress: Bytes
}
```

For the schema of the actual offchain data that the GraphQL endpoint should serve, implementers may define their own schema based on their specific needs. For L2 implementations with indexable events, see ENSIP-X which defines standard events and schemas.


#### L2

L2 graphql URL is discoverable via `metadata` function `graphqlUrl` field.

```graphql
type Domain {
  id: ID!
  name: String
  namehash: Bytes
  labelName: String
  labelhash: Bytes
  resolvedAddress: Bytes
  parent: Domain
  subdomains: [Domain]
  subdomainCount: Int!
  resolver: Resolver!
  expiryDate: BigInt
}

type Resolver @entity {
  id: ID!
  node: Bytes
  address: Bytes
  domain: Domain
  addr: Bytes
  contentHash: Bytes
  texts: [String!]
  coinTypes: [BigInt!]
}
```

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).